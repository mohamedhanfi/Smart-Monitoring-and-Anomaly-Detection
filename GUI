import cv2
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from PIL import Image, ImageTk
import threading
import time
from datetime import datetime
import torch
import torchvision.transforms as transforms
from transformers import ViTModel, ViTConfig, logging
from tkinter import PhotoImage

# Suppress unnecessary warnings from transformers
logging.set_verbosity_error()

# Constants
IMG_SIZE = 224
CLASS_MAPPING = {
    0: "Arson",
    1: "Fighting",
    2: "RoadAccidents",
    3: "Robbery",
    4: "Normal"
}
CONFIDENCE_THRESHOLD = 0.75

# Define the VideoViT model
class VideoViT(torch.nn.Module):
    def __init__(self, num_classes=5):
        super().__init__()
        # Load configuration and model from pretrained weights
        config = ViTConfig.from_pretrained("google/vit-base-patch16-224-in21k")
        self.vit = ViTModel.from_pretrained(
            "google/vit-base-patch16-224-in21k",
            config=config,
            add_pooling_layer=False
        )
        # Temporal encoder for processing video sequences
        self.temporal_encoder = torch.nn.TransformerEncoder(
            torch.nn.TransformerEncoderLayer(d_model=768, nhead=8),
            num_layers=2
        )
        # Classifier head
        self.classifier = torch.nn.Sequential(
            torch.nn.LayerNorm(768),
            torch.nn.Linear(768, num_classes)
        )

    def forward(self, x):
        batch_size, timesteps, C, H, W = x.shape
        x = x.view(-1, C, H, W)  # Flatten batch and timesteps for ViT
        vit_outputs = self.vit(x).last_hidden_state
        cls_tokens = vit_outputs[:, 0, :].view(batch_size, timesteps, -1)  # Extract CLS tokens
        temporal_features = self.temporal_encoder(cls_tokens)
        pooled = temporal_features.mean(dim=1)  # Pool over time
        return self.classifier(pooled)

class SmartMonitoringApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Smart Monitoring & Anomaly Detection")
        self.root.state('zoomed')  # Start in full-screen mode

        # Load background image
        self.bg_image_path = "work/assests/111.jpg"
        self.bg_image = Image.open(self.bg_image_path)
        self.bg_image = self.bg_image.resize((self.root.winfo_screenwidth(), self.root.winfo_screenheight()))
        self.bg_photo = ImageTk.PhotoImage(self.bg_image)
        self.bg_label = tk.Label(self.root, image=self.bg_photo)
        self.bg_label.place(relwidth=1, relheight=1)

        # Load users
        self.users_file = "users.txt"
        self.users = self.load_users()

        # Styles
        style = ttk.Style()
        style.theme_use('clam')
        style.configure("TFrame", background="black")
        style.configure("TLabel", background="black", foreground="white")
        style.configure("TEntry", fieldbackground="black", foreground="white")
        style.configure("TButton", background="black", foreground="white")
        self.root.configure(bg="black")

        # Login UI
        self.login_frame = ttk.Frame(self.root, padding=20)
        self.login_frame.place(relx=0.5, rely=0.5, anchor="center")
        self.user_icon = PhotoImage(file="work/assests/icons8-male-user-50.png")
        self.password_icon = PhotoImage(file="work/assests/icons8-password-48.png")
        ttk.Label(self.login_frame, text="Username:", font=("Arial", 14)).grid(row=0, column=0, padx=10, pady=15, sticky="w")
        ttk.Label(self.login_frame, image=self.user_icon, background="black").grid(row=0, column=1)
        self.username_entry = ttk.Entry(self.login_frame, font=("Arial", 14))
        self.username_entry.grid(row=0, column=2, padx=10)
        ttk.Label(self.login_frame, text="Password:", font=("Arial", 14)).grid(row=1, column=0, padx=10, pady=15, sticky="w")
        ttk.Label(self.login_frame, image=self.password_icon, background="black").grid(row=1, column=1)
        self.password_entry = ttk.Entry(self.login_frame, show="*", font=("Arial", 14))
        self.password_entry.grid(row=1, column=2, padx=10)
        ttk.Button(self.login_frame, text="Login", command=self.login).grid(row=2, column=1, columnspan=2, pady=15)

        # Main frames & Go Back button
        self.main_frame = ttk.Frame(root)
        self.report_frame = ttk.Frame(root)
        self.admin_frame = ttk.Frame(root)
        self.go_back_button = ttk.Button(self.root, text="Go Back", command=self.go_back)
        self.go_back_button.pack(padx=10, pady=10)


        # Camera setup
        self.num_cameras = 8
        self.captures = [cv2.VideoCapture(f"E:\\Graduation project\\dataset\\clases\\Arson\\Arson00{i+1}_x264.mp4") for i in range(self.num_cameras)]
        self.camera_labels = []

        # Reports panel
        self.report_listbox = tk.Listbox(self.report_frame, width=50, height=15, font=("Arial", 14), background="black", fg="white")
        self.report_listbox.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        # Admin panel
        self.operator_listbox = tk.Listbox(self.admin_frame, width=50, height=15, font=("Arial", 14), background="black", fg="white")
        self.operator_listbox.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        self.add_operator_button = ttk.Button(self.admin_frame, text="Add Operator", command=self.add_operator)
        self.add_operator_button.pack(padx=10, pady=10)
        # self.go_back_button = ttk.Button(self.root, text="Go Back", command=self.go_back)
        # self.go_back_button.pack(padx=10, pady=10)

        # Model setup
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model = VideoViT(num_classes=5)
        # Load pre-trained weights if available (update path as needed)
        try:
            self.model.load_state_dict(torch.load("best_model.pth", map_location=self.device))
        except FileNotFoundError:
            print("Warning: best_model.pth not found. Using untrained model.")
        self.model.to(self.device)
        self.model.eval()
        self.model_lock = threading.Lock()

        # Preprocessing transform
        self.transform = transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ])

    def load_users(self):
        users = {}
        try:
            with open(self.users_file, "r") as file:
                for line in file:
                    username, password, role = line.strip().split(",")
                    users[username] = {"password": password, "role": role}
        except FileNotFoundError:
            with open(self.users_file, "w") as file:
                file.write("admin,admin123,admin\n")
            users = {"admin": {"password": "admin123", "role": "admin"}}
        return users

    def login(self):
        username = self.username_entry.get()
        password = self.password_entry.get()
        if username in self.users and self.users[username]["password"] == password:
            self.login_frame.destroy()
            if self.users[username]["role"] == "admin":
                self.show_admin_interface()
            else:
                self.show_operator_interface()
        else:
            messagebox.showerror("Login Failed", "Invalid username or password")

    def show_operator_interface(self):
        self.main_frame.pack(padx=20, pady=20, side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.report_frame.pack(padx=20, pady=20, side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.create_camera_grid()
        self.start_video_threads()

    def create_camera_grid(self):
        rows, cols = 4, 2
        for i in range(self.num_cameras):
            frame = ttk.LabelFrame(self.main_frame, text=f"Camera {i+1}")
            frame.grid(row=i // cols, column=i % cols, padx=10, pady=10, sticky="nsew")
            label = tk.Label(frame)
            label.pack(fill=tk.BOTH, expand=True)
            self.camera_labels.append(label)
        for i in range(rows):
            self.main_frame.grid_rowconfigure(i, weight=1)
        for j in range(cols):
            self.main_frame.grid_columnconfigure(j, weight=1)

    def start_video_threads(self):
        for i in range(self.num_cameras):
            threading.Thread(target=self.update_camera, args=(i,), daemon=True).start()

    def update_camera(self, index):
        frame_buffer = []
        while True:
            ret, frame = self.captures[index].read()
            if not ret:
                self.captures[index].set(cv2.CAP_PROP_POS_FRAMES, 0)  # Loop video
                continue

            # Display frame
            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame_resized = cv2.resize(frame_rgb, (400, 300))
            img = ImageTk.PhotoImage(image=Image.fromarray(frame_resized))
            self.camera_labels[index].imgtk = img
            self.camera_labels[index].config(image=img)

            # Add to buffer for inference
            pil_img = Image.fromarray(frame_rgb).resize((IMG_SIZE, IMG_SIZE))
            frame_buffer.append(pil_img)

            if len(frame_buffer) == 16:  # Process 16-frame sequences
                threading.Thread(target=self.infer, args=(frame_buffer, index), daemon=True).start()
                frame_buffer = []  # Clear buffer

            time.sleep(0.03)  # Control frame rate

    def infer(self, frames, index):
        # Preprocess frames
        processed_frames = [self.transform(img) for img in frames]
        input_tensor = torch.stack(processed_frames).unsqueeze(0).to(self.device)  # [1, 16, 3, 224, 224]

        # Perform inference
        with self.model_lock:
            with torch.no_grad():
                outputs = self.model(input_tensor)
                probabilities = torch.nn.functional.softmax(outputs, dim=1)
                confidence, pred_idx = torch.max(probabilities, dim=1)
                confidence = confidence.item()
                predicted_class = CLASS_MAPPING[pred_idx.item()]

        # Report anomaly if detected
        if predicted_class != "Normal" and confidence > CONFIDENCE_THRESHOLD:
            self.report_anomaly(index, predicted_class, confidence)

    def report_anomaly(self, index, anomaly_class, confidence):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        report = f"[{timestamp}] {anomaly_class} detected in Camera {index+1} with confidence {confidence:.2%}\n"
        self.report_listbox.insert(tk.END, report)
        self.report_listbox.insert(tk.END, "-" * 50 + "\n")

    def show_admin_interface(self):
        self.admin_frame.pack(padx=20, pady=20, side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.report_frame.pack(padx=20, pady=20, side=tk.RIGHT, fill=tk.BOTH, expand=True)
        for username, info in self.users.items():
            if info["role"] == "operator":
                self.operator_listbox.insert(tk.END, username)

    def add_operator(self):
        username = simpledialog.askstring("Add Operator", "Enter username:")
        if username and username not in self.users:
            password = simpledialog.askstring("Add Operator", "Enter password:", show="*")
            if password:
                with open(self.users_file, "a") as file:
                    file.write(f"{username},{password},operator\n")
                self.users[username] = {"password": password, "role": "operator"}
                self.operator_listbox.insert(tk.END, username)
                messagebox.showinfo("Success", f"Operator '{username}' added!")
            else:
                messagebox.showerror("Error", "Password cannot be empty!")
        else:
            messagebox.showerror("Error", "Username cannot be empty or already exists!")

    def go_back(self):
        for widget in self.root.winfo_children():
            widget.destroy()
        self.__init__(self.root)

    def __del__(self):
        for cap in self.captures:
            if cap.isOpened():
                cap.release()

if __name__ == "__main__":
    root = tk.Tk()
    app = SmartMonitoringApp(root)
    root.mainloop()